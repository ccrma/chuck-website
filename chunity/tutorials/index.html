<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml/DTD/xhtml1-strict.dtd">
<!-- saved from url=(0052)http://chuck.stanford.edu/doc/language/overview.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>ChucK - [Unity: Tutorials]</title>
<link rel="stylesheet" type="text/css" href="../css/style.css">
<link rel="stylesheet" type="text/css" href="../css/prism.css">
</head>
<body bgcolor="#ffffff" text="#000000">
<center>

<!-- all in a big fat table-->

<table id="page_layout" border="0" width="640">

<!-- heading row-->

<tbody><tr><td>
<div id="chuck_header">
<center>
<h1>
<strong>Chunity</strong> : Tutorials
</h1>

<table border="0">
<tbody><tr><td>
  	<div id="chuck_revision">
	version: 1.4.x.x (numchucks)
  	</div>
  	
</td></tr>
</tbody></table>

<hr width="20%">
</center>
</div>
</td></tr>

<!-- navigation bar -->

<tr><td>
<center>
<div class="chuck_nav">

	<table border="0"><tbody><tr><td>
	<center>
	<div class="chuck_nav_bar">	
  (up): <a href="..">chunity</a> <!-- | (next): <a href="">next link</a> &gt;  -->
	</div>
	</center>  
	</td></tr></tbody></table>

</div>
</center>
</td></tr>

<!-- lang specification section -->
<tr><td>
<div id="chuck_body">

<div id="lang_topic_body">

<h1><strong>Overview</strong></h1>

<p>ChucK is a strongly-typed, <strong><em>strongly-timed</em></strong>, concurrent audio 
and multimedia programming language.  It is compiled into virtual 
instructions, which are immediately run in the ChucK Virtual Machine.  
This guide documents how to use the language in the Unity game engine environment.
</p>

<!-- additional sub topic sections go here... -->

<div class="lang_subtopic_body">
<h2><strong>Tutorials</strong></h2>

<ul>
<li><a href="#setup">Setup</a></li>
<li><a href="#unityvariables1">Responding to Unity Events / Using Unity Variables (1)</a></li>
<li><a href="#spatialization">Spatialization</a></li>
<li><a href="#audiofiles">Audio Files</a></li>
<li><a href="#console">Printing to the Unity Console</a></li>
<li><a href="#unityvariables2">Using Unity Variables (2): ChucK Global Variables</a></li>
<li><a href="#getglobal">Getting ChucK Global Variables</a></li>
<li><a href="#chugins">Chugins</a></li>
</ul>

<p>
These tutorials start from a working Roll a Ball game (<a target="_blank" href="https://unity3d.com/learn/tutorials/projects/roll-ball-tutorial">&#10144;Official Unity Tutorial</a>).<br />
You are encouraged to follow that tutorial first if you are unfamiliar with working in Unity.
If you'd rather not go through the Roll a Ball tutorial, you can download <a href="../files/Roll-a-ball_without_audio.zip" download>the resulting project</a>.
</p>

<p>If you know your way around Unity, you'll probably do fine following the below tutorials
to add ChucK to any existing Unity project.</p>

<p>These tutorials were created with Unity version 5.6.0f3. This version of Chunity was compiled for Unity 2018.2.11f1.</p>


</div>

<div id="setup" class="lang_subtopic_body">
<h2><strong>Setup</strong></h2>
<ol>
<li>
<p>First, you'll need to add the <a 
href="../files/chunity-2.0.0.unitypackage" download>necessary files</a> into the project. 
    Add this package to your project via the <span class="mono2">Assets > 
Import Package</span> menu. (NOTE: alternately, you can import 
Chunity from the Asset Store for this step.) </p>
<img class="tutorialimg" src="../images/tutorial1/1.png" width=600 />
<p>
    You will see something like this. Make sure to import all of the files. The names of the folders <span class="mono2">Plugins</span>, <span class="mono2">Resources</span>, 
    and <span class="mono2">StreamingAssets</span> are especially important, since these are folders that Unity treats specially because of their names.
</p>
<img class="tutorialimg" src="../images/tutorial1/2.png" width=700 />

<p>If you are replacing an older version of Chunity, restart Unity so that the new plugins are loaded correctly.</p>
<img class="tutorialimg" src="../images/tutorial1/restart.png" width=500 />


<p>Now, you've finished adding the necessary files to use ChucK in your project! <br /><br /><br /></p>
</li>

<li>
<p>Next, we'll add an instance of ChucK to our scene. This tutorial will cover how to add ChucK to an individual
   game object. To use ChucK as a plugin in an Audio Mixer, see the <a href="../with-plugins">Plugin Tutorials</a>.</p>

<p>First, we need to add a global game object to hold our scene's <span class="mono2">ChuckMainInstance</span>. 
   All objects that play ChucK code will contain a reference to this object.
   (It's possible to have as many of these in a scene as you need, but in practice, this is only for
   special circumstances like accessing two different microphones.)
</p>
<p>Here, I have created a new empty game object called <span class="mono2">TheChuck</span> and I am adding the
   <span class="mono2">ChuckMainInstance</span> component to it.</p>
<img class="tutorialimg" src="../images/tutorial1/3.png" width=600 />

<p>Doing so will automatically add an <span class="mono2">Audio Source</span> to the object.
   This is used to fetch the microphone input correctly. You can ignore it. 
   (If you want to play audio files in ChucK, you
   should not use this Audio Source but should instead follow the directions in the <a href="#audiofiles">Audio Files</a> tutorial.)
</p><p>   You can also ignore the <span class="mono2">Microphone Identifier</span> field,
   unless you want to use a microphone different than your system's default microphone.
   (In that case, put some substring of the name of the microphone into this field.)
</p>
<img class="tutorialimg" src="../images/tutorial1/4.png" width=500 />

<p>Now that we have created a <span class="mono2">ChuckMainInstance</span> for our scene, we can
   begin creating <span class="mono2">ChuckSubInstances</span> on game objects in our scene.
</p>

<p>Pick the game object you want to add ChucK to. In this case, I will add it to my <span class="mono2">Player</span> object.</p>
<p>Add a <span class="mono2">ChuckSubInstance</span> script to this game object.</p>

<p>By adding this script, an <span class="mono2">Audio Source</span> will also be added to your game object.
   This Audio Source is used by ChucK to function correctly. (If you want to play audio files in ChucK, you
   should not use this Audio Source but should instead follow the directions in the <a href="#audiofiles">Audio Files</a> tutorial.)</p>

<img class="tutorialimg" src="../images/tutorial1/5.png" width=800 />

<p>The next step is to give this component a reference to the <span class="mono2">ChuckMainInstance</span>
   we created earlier. Drag it into the <span class="mono2">Chuck Main Instance</span> slot on the new
   <span class="mono2">ChuckSubInstance</span> component.
</p>
<img class="tutorialimg" src="../images/tutorial1/6.png" width=600 />

<p>If you are using ChucK spatially, you can edit the 3D Sound options of this Audio Source. Since we are not using this 
   ChucK spatially, we can leave all the settings alone. Now we are done adding a ChucK Instance to our scene!</p>
</li>
<img class="tutorialimg" src="../images/tutorial1/7.png" width=400 />

<li>
<p>Next, let's access this ChucK plugin through a Unity C# script.</p>

<p>Since I am adding ChucK to my Roll a Ball project (<a target="_blank" href="https://unity3d.com/learn/tutorials/projects/roll-ball-tutorial">&#10144;Official Unity Tutorial</a>),
   I'll add ChucK to my PlayerController script. This script operates on the same object I added the ChucK Instance to.</p>
<img class="tutorialimg" src="../images/tutorial1/8.png" width=300 />


<p>Now, let's write our first ChucK script in Unity!</p>
<p>Here's a new ChucK script. It's sent to the ChucK plugin using <br />
   <span class="mono2">GetComponent&lt;ChuckSubInstance&gt;().RunCode</span>, where the argument
   is a string with ChucK code that will be compiled and run on the fly.</p>
<p>This particular ChucK script connects a sine wave to the output,
   then sets its frequency randomly between 300 Hz and 1000 Hz every 100 ms, forever.</p>
<p>(Note: <span class="mono2">@""</span> denotes a multi-line string.)</p>
<pre data-line="8-15" class="line-numbers"><code class="language-csharp">void Start()
{
	rb = GetComponent&lt;Rigidbody&gt;();
	count = 0;
	SetCountText();
	winText.text = "";

	<span class="bold">GetComponent&lt;ChuckSubInstance&gt;().RunCode(@"
		SinOsc foo => dac;
		while( true )
		{
			Math.random2f( 300, 1000 ) => foo.freq;
			100::ms => now;
		}
	");</span>
}</code></pre>
<br />
<p>Let's test it! Enter play mode.</p>
<img class="tutorialimg" src="../images/tutorial1/9.png" width=600 />

<p>And you can hear audio! (Check the ChuckSubInstance script to see the audio levels for the instance while the game is in Play Mode.)</p>


<p><strong>Congratulations!</strong> You now have ChucK working inside of a Unity project!!</p>

</li>
</ol>
</div>



<div id="unityvariables1" class="lang_subtopic_body">
<h2><strong>Responding to Unity Events / Using Unity Variables (1)</strong></h2>

<p>In the previous tutorial, we set up ChucK in a Unity project and 
   wrote a script that plays a sine wave with a randomly-changing frequency
   forever. Let's change that script into something a bit more appropriate
   for our Roll a Ball game.</p>
<p>First, delete the original call to <span class="mono2">ChuckSubInstance.RunCode()</span>
   so that our original ChucK script doesn't play anymore.</p>
<p>Now, I want to write a script that plays every time our Player object
   picks up a Pick Up object. This will go in the <span class="mono2">OnTriggerEnter</span>
   function, where we detect collisions with trigger objects.</p>

<pre data-line="9-16" class="line-numbers"><code class="language-csharp">void OnTriggerEnter( Collider other )
{
	if( other.gameObject.CompareTag( "Pick Up" ) )
	{
		other.gameObject.SetActive( false );
		count = count + 1;
		SetCountText();

		<span class="bold">GetComponent&lt;ChuckSubInstance&gt;().RunCode(@"
			SinOsc foo => dac;
			repeat( 5 )
			{
				Math.random2f( 300, 1000 ) => foo.freq;
				100::ms => now;
			}
		");</span>
	}
}</code></pre>

<p>Here, I've added a new ChucK script in that function. It runs directly after
   we increment the count of how many pickup objects have been picked up so far.
   It's very similar to the first script, but only plays 5 different frequencies
   instead of running forever. ( <span class="mono2">repeat( 5 )</span> instead
   of <span class="mono2">while( true )</span> ).</p>

<p>This is a good start, but it's not very interesting. How about we make it repeat
   a number of times according to the current <span class="mono2">count</span>?</p>
<p>To do this, we can use the <span class="mono2">string.Format()</span> function.
   This function takes a string with format substrings that look like <span class="mono2">{0}</span>,
   <span class="mono2">{1:0.00}</span>, <span class="mono2">{2}</span>, etc.
   and takes arguments to fill all the numbered slots.</p>
<p>Because arguments to <span class="mono2">string.Format()</span> are
   specified with <span class="mono2">{</span> and <span class="mono2">}</span>, 
   we have to write <span class="mono2">{{</span> if we mean <span class="mono2">{</span>
   and <span class="mono2">}}</span> if we mean <span class="mono2">}</span>.</p>
<p>So, to translate the above script into one that repeats <span class="mono2">count</span>
   times instead of <span class="mono2">5</span> times, I replace the 
   <span class="mono2">5</span> with a <span class="mono2">{0}</span>,
   replace all <span class="mono2">{</span> and <span class="mono2">}</span> with
   <span class="mono2">{{</span> and <span class="mono2">}}</span>, then wrap the
   code string in a call to <span class="mono2">string.Format()</span> and include
   <span class="mono2">count</span> as the second argument.</p>

<!-- TODO: consider figuring out how to format the {0} a different color. 
     It's not supported natively by the code highlighter I'm using. -->
<!-- TODO: make this look not terrible with the background colors;
     it is very hard to see the highlight when it's white/blue.   -->
<pre data-line="9,11-12,15" class="line-numbers"><code class="language-csharp">void OnTriggerEnter( Collider other )
{
	if( other.gameObject.CompareTag( "Pick Up" ) )
	{
		other.gameObject.SetActive( false );
		count = count + 1;
		SetCountText();

		GetComponent&lt;ChuckSubInstance&gt;().RunCode( <span class="bold">string.Format( @"</span>
			SinOsc foo => dac;
			<span class="bold">repeat( {0} )
			{{</span>
				Math.random2f( 300, 1000 ) => foo.freq;
				100::ms => now;
			<span class="bold">}}</span>
		", count ) );
	}
}</pre></code>

<p>It's that simple to write and launch ChucK code that responds to a Unity event
   and uses values from current Unity variables!</p>

</div>

<div id="spatialization" class="lang_subtopic_body">
<h2><strong>Spatialization</strong></h2>

<p>Spatialization is the technique of processing a stream of audio so that it
   is perceived to be originating from a particular place in the environment.</p>
<p>Here, I will demonstrate how to achieve a simple form of spatialization in
   Unity to spatialize sounds generated from a ChucK plugin.</p>
<p>This technique will set the overall volume according to the distance from
   the audio listener to the source of audio, and will set the relative volume
   of the left and right channels according to the direction between the audio
   listener and the source of audio, but will not use HRTFs or change the spectral
   content of the source of audio in any way.</p>
<!-- 
<p>(There is another script to use if you'd like to use your own Spatializer Audio Plugin.
   More on that to come later.)</p>
 -->

<ol>
<li>
<p>First, we will set up a new ChucK plugin. Let's select a Unity object that we will be spatializing.</p>

<p>I'd like for one of my Pick Up objects to create spatialized sound, so I'll select
   one of these objects from the Hierarchy pane.</p>
<img class="tutorialimg" src="../images/tutorial3/1.png" width=800 />

<p>Add a ChuckSubInstance to this object.</p>
<img class="tutorialimg" src="../images/tutorial3/2.png" width=600 />

<p>And select the <span class="mono2">spatialize</span> option!</p>
<img class="tutorialimg" src="../images/tutorial3/3.png" width=400 />

<p>Note that an <span class="mono2">AudioSource</span> has been added as a result of
   adding the ChuckSubInstance script. ChucK uses this AudioSource to capture spatialization
   data. ChucK will use the AudioClip, Play On Awake, Loop, and Spatial Blend fields, setting
   them automatically whenever the scene is run. (If you'd like to play an audio file, use
   <a href="#audiofiles">audio files in ChucK</a> instead.)</p>
<p>You can use the 3D sound settings to adjust how your ChucK script is spatialized.</p>
<img class="tutorialimg" src="../images/tutorial3/4.png" width=400 />

<p>In particular, I am going to change my maximum distance to be 40, since my scene is rather small.</p>
<img class="tutorialimg" src="../images/tutorial3/5.png" width=400 />
<p>Now, the ChucK instance is all set up for spatial audio!<br /><br/></p>
</li>

<li>
<p>Now, let's write a script to use the new spatialized ChucK instance.</p>
<p>I'll add a new script called <span class="mono2">PickupAudio</span> to my
   pickup object -- the same object that has the <span class="mono2">ChuckSubInstance</span>
   component from the last step.</p>
<img class="tutorialimg" src="../images/tutorial3/6.png" width=800 />

<p>(Don't forget to move your new script to the <span class="mono2">Scripts</span> folder!)</p>
<img class="tutorialimg" src="../images/tutorial3/7.png" width=300 />

<p>We write ChucK code for a spatialized ChucK instance in exactly the same way as for a 
   non-spatialized ChucK instance!</p>
<pre class="line-numbers"><code class="language-csharp">public class PickupAudio : MonoBehaviour
{
	void Start()
	{
		GetComponent&lt;ChuckSubInstance&gt;().RunCode(@"
			TriOsc spatialOsc => dac;
			while( true )
			{
				Math.random2f( 300, 1000 ) => spatialOsc.freq;
				50::ms => now;
			}
		" );
	}
}</code></pre>

</li>

<li>
<p>Let's test our new script to see if it's working!</p>
<p>When my Audio Listener has an the Audio Source on its right, then the spatialized audio output is louder
   in the left channel than the right.</p>
<img class="tutorialimg" src="../images/tutorial3/9.png" width=600 />

<p>And, when my Audio Listener is on the left side of an Audio Source, the spatialized audio
   is louder on the right channel than the left! The reason that the audio is so quiet in both cases is
   that the Audio Listener is on our scene's Camera, so in both cases the Audio Listener is actually pretty
   far away from the Audio Source.</p>
<img class="tutorialimg" src="../images/tutorial3/10.png" width=600 />
<p>Congratulations! You've just set up your first spatial audio script in Unity using ChucK!<br /><br /><br /></p>
</li>

<li>
<p>(Addendum) In the spirit of designing audio and visuals in tandem, I'd like to make
   the spatialized Pick Up stand out from the rest of the Pick Ups.
   This way, there will be a visual cue that corresponds to the spatial sound cues.</p>
<p>I'll start by making the spatialized Pick Up a different color.</p>
<p>Highlight the Pick Up material in the Project pane.
   This material is what gives the Pick Ups their yellow color.</p>
<img class="tutorialimg" src="../images/tutorial3/11.png" width=300 />

<p>Duplicate it using CTRL-D (Windows) or CMD-D (OS X).</p>
<img class="tutorialimg" src="../images/tutorial3/12.png" width=300 />

<p>Give the duplicated material a new name. I'll call mine Spatial Pick Up.</p>
<img class="tutorialimg" src="../images/tutorial3/13.png" width=250 />

<p>Next, I'll change the color of my new material by editing the Albedo property.</p>
<img class="tutorialimg" src="../images/tutorial3/14.png" width=400 />

<p>There! Now, any object using the Spatial Pick Up material will be colored green.</p>
<img class="tutorialimg" src="../images/tutorial3/15.png" width=400 />

<p>Apply the new material to the Pick Up we added spatialization to by dragging
   the material from the Project pane onto the Pick Up in the Hierarchy pane.</p>
<img class="tutorialimg" src="../images/tutorial3/16.png" width=250 />

<p>Now, the Pick Up looks different! But, I still don't think that its visual
   appearance corresponds very well with the sound of a triangle wave oscillator
   with a rapidly-changing frequency...</p>
<img class="tutorialimg" src="../images/tutorial3/17.png" width=700 />

<p>Let's change this by adding a rapid movement to the spatial Pick Up!</p>
<p>We'll do this by modifying the existing <span class="mono2">Rotator</span>
   class, which is responsible for rotating all the Pick Ups.</p>
<p>Since we want to create a behavior that is turned on only for some
   Pick Ups, we'll add a new public boolean that controls whether the behavior
   is turned on or off.</p>
<pre data-line="3" class="line-numbers"><code class="language-csharp">public class Rotator : MonoBehaviour
{
	<span class="bold">public bool rotateRandomly = false;</span>

	void Update()
	{
		transform.Rotate( new Vector3( 15, 30, 45 ) * Time.deltaTime );
	}
}</code></pre>

<p>Next, we'll add a new <span class="mono2">Vector3</span> local variable to 
   the <span class="mono2">Update()</span> function. If the <span class="mono2">rotateRandomly</span>
   behavior is enabled, then the <span class="mono2">rotateAmount</span> vector is
   set to have three random values, each selected uniformly from the range 
   <span class="mono2">[100, 800)</span>.
   If <span class="mono2">rotateRandomly</span> is not enabled, then the 
   <span class="mono2">rotateAmount</span> will be the same as it was before we
   started modifying this script.
   Finally, we'll modify the call to <span class="mono2">transform.Rotate</span>
   to take our new <span class="mono2">rotateAmount</span> variable.</p>
<pre  class="line-numbers"><code class="language-csharp">void Update()
{
	// choose rotation
	Vector3 rotateAmount;
	if( rotateRandomly )
	{
		// vector where x, y, z all in [100, 800)
		rotateAmount = new Vector3(
			Random.Range( 100, 800 ),
			Random.Range( 100, 800 ),
			Random.Range( 100, 800 )
		);
	}
	else
	{
		// original rotation vector
		rotateAmount = new Vector3( 15, 30, 45 );
	}

	// apply rotation
	transform.Rotate( rotateAmount * Time.deltaTime );
}</code></pre>

<p>The last thing to do is to set the new Rotate Randomly boolean to be checked on
   for the Pick Up we spatialized earlier.</p>
<img class="tutorialimg" src="../images/tutorial3/20.png" width=500 />

<p>When you've done that, it will look like this for the spatial Pick Up, but will
   remain unchecked for the rest of the Pick Ups.</p>
<img class="tutorialimg" src="../images/tutorial3/21.png" width=400 />

<p>Now, the spatial Pick Up looks really visually distinct, and its movement aligns
   well with the audio it is emitting!</p>
<img class="tutorialimg" src="../images/tutorial3/22.png" width=700 />
<p>Congratulations! You've finished integrating spatial audio into a ChucK project! </p>
</li>
</ol>
</div>

<div id="audiofiles" class="lang_subtopic_body">
<h2><strong>Audio Files</strong></h2>
<p>This tutorial will walk through writing a ChucK script that plays an audio
   file. The script will play an audio file whenever the Player game object collides
   with another game object. The audio file's amplitude and speed of playback will 
   depend on a Unity variable, added to the script with string formatting. </p>
<p>For any file to be copied directly to the file system for your code to access
   during runtime, it must be located inside of a special folder called <span class="mono2">StreamingAssets</span>.
   Create this folder in your Project pane and put an audio file you'd like to
   use inside it. My audio file is called <span class="mono2">impact.wav</span>.</p>
<img class="tutorialimg" src="../images/tutorial4/1.png" width=300 />

<p>Since I'd like to play this file when the Player collides with another game object,
   I'll add an <span class="mono2">OnCollisionEnter()</span> method to my Player class.</p>

<p>To determine what range of possible values the collision's velocity magnitude 
   can take on, I'll use Unity's Debug Log to print out the value, enter play
   mode, and cause collisions with the game walls at a variety of velocities.</p>

<pre class="line-numbers"><code class="language-csharp">void OnCollisionEnter( Collision collision )
{
	float intensity = collision.relativeVelocity.magnitude;

	Debug.Log( intensity );
}</code></pre>


<p>Based on this experiment, it looks like the relevant range of my <span class="mono2">intensity</span>
   variable will be roughly <span class="mono2">[0, 16]</span>.</p>
<img class="tutorialimg" src="../images/tutorial4/2.png" width=600 />

<p>I'll scale the intensity down to roughly <span class="mono2">[0, 1]</span> by dividing it by 
   <span class="mono2">16</span>, then clamp it to exactly <span class="mono2">[0, 1]</span>.
   Finally, I'll square this value so that the sound changes quadratically with an increase in velocity,
   rather than linearly. This will help especially fast collisions to stand out more.</p>
<pre class="line-numbers"><code class="language-csharp">void OnCollisionEnter( Collision collision )
{
	// map and clamp from [0, 16] to [0, 1]
	float intensity = Mathf.Clamp01( collision.relativeVelocity.magnitude / 16 );

	// square it to make the ramp upward more dramatic
	intensity = intensity * intensity;
}</code></pre>


<p>Finally, I'll add my ChucK code. The intensity parameter is inserted just as in the
   <a href="#unityvariables1">Using Unity Variables(1)</a> tutorial. Note that when
   writing multi-line strings, any single quotes <span class="mono2">"</span> must be
   specified by writing <span class="mono2">""</span>.</p>
<p>The sound file itself is accessed via its filename. Note that in Unity, the
   <span class="mono2">me.dir()</span> ChucK expression refers automatically to the 
   <span class="mono2">StreamingAssets</span> folder for code that is run using 
   <span class="mono2">ChuckSubInstance.RunCode()</span>.</p>

<pre data-line="10-11,16-20" class="line-numbers"><code class="language-csharp">void OnCollisionEnter( Collision collision )
{
	// map and clamp from [0, 16] to [0, 1]
	float intensity = Mathf.Clamp01( collision.relativeVelocity.magnitude / 16 );

	// square it to make the ramp upward more dramatic
	intensity = intensity * intensity;

	GetComponent&lt;ChuckSubInstance&gt;().RunCode( string.Format( @"
		<span class="bold">SndBuf impactBuf => dac;
		me.dir() + ""impact.wav"" => impactBuf.read;</span>

		// start at the beginning of the clip
		0 => impactBuf.pos;
	
		// set rate: least intense is fast, most intense is slow; range 0.4 to 1.6
		<span class="bold">1.5 - {0} + Math.random2f( -0.1, 0.1 ) => impactBuf.rate;</span>

		// set gain: least intense is quiet, most intense is loud; range 0.05 to 1
		<span class="bold">0.05 + 0.95 * {0} => impactBuf.gain;</span>

		// pass time so that the file plays
		impactBuf.length() / impactBuf.rate() => now;

	", intensity ) );
}</code></pre>



<p>It's that simple to write ChucK scripts that use audio files in Unity! Just add your
   audio files to the <span class="mono2">StreamingAssets</span> folder and access their
   filenames in ChucK using <span class="mono2">me.dir()</span>.</p>
</div>

<div id="console" class="lang_subtopic_body">
<h2><strong>Printing to the Unity Console</strong></h2>
<p>It's easy to write print statements in ChucK that you can see in Unity.
   Any print statements written using <span class="mono2">chout</span>, 
   <span class="mono2">cherr</span>, or the "gack" triple-angle-brackets 
   (&nbsp;<span class="mono2"><<< "hello, world" >>>;</span>&nbsp;) will
   automatically appear in the Unity console.</p>
<p>For example, this ChucK script computes a value with a random error added to it,
   then prints the resulting value to the console.</p>

<pre data-line="8-11" class="line-numbers"><code class="language-csharp">GetComponent&lt;ChuckSubInstance&gt;().RunCode( string.Format( @"
	SndBuf impactBuf => dac;
	me.dir() + ""impact.wav"" => impactBuf.read;

	// start at the beginning of the clip
	0 => impactBuf.pos;
			
	// set rate: least intense is fast, most intense is slow; range 0.4 to 1.6
	1.5 - {0} + Math.random2f( -0.1, 0.1 ) => impactBuf.rate;
			
	<span class="bold">chout <= ""Rate is "" <= impactBuf.rate() <= IO.newline();</span>

	// set gain: least intense is quiet, most intense is loud; range 0.05 to 1
	0.05 + 0.95 * {0} => impactBuf.gain;

	// pass time so that the file plays
	impactBuf.length() / impactBuf.rate() => now;

", intensity ) );</code></pre>



<p></p>
<img class="tutorialimg" src="../images/tutorial5/2.png" width=400 />

</div>

<div id="unityvariables2" class="lang_subtopic_body">
<h2><strong>Using Unity Variables (2): ChucK Global Variables</strong></h2>
<p>This tutorial documents ChucK global variables. Using this type of variable 
   allows you to set and get the values of ChucK variables after a ChucK script
   is already running. Currently, it can be applied to ints, floats, and strings. It can
   also be applied to Events, for which the relevant actions are signaling and
   broadcasting the event. We are always adding support for more types of global
   variables!</p>
<p>This tutorial will also go over writing a function in ChucK and running that
   function in a new shred (the word for threads in ChucK).</p>
<p>Let's start with the ChucK script that we wrote in the <a href="#audiofiles">Audio Files</a>
   tutorial. This ChucK script plays an audio file and exits immediately afterward. The script
   is compiled and run every time the Player object has a collision.</p>

<pre class="line-numbers"><code class="language-csharp">void OnCollisionEnter( Collision collision )
{
	// map and clamp from [0, 16] to [0, 1]
	float intensity = Mathf.Clamp01( collision.relativeVelocity.magnitude / 16 );

	// square it to make the ramp upward more dramatic
	intensity = intensity * intensity;

	GetComponent&lt;ChuckSubInstance&gt;().RunCode( string.Format( @"
		SndBuf impactBuf => dac;
		me.dir() + ""impact.wav"" => impactBuf.read;

		// start at the beginning of the clip
		0 => impactBuf.pos;
			
		// set rate: least intense is fast, most intense is slow; range 0.4 to 1.6
		1.5 - {0} + Math.random2f( -0.1, 0.1 ) => impactBuf.rate;
	
		chout <= ""Rate is "" <= impactBuf.rate() <= IO.newline();

		// set gain: least intense is quiet, most intense is loud; range 0.05 to 1
		0.05 + 0.95 * {0} => impactBuf.gain;

		// pass time so that the file plays
		impactBuf.length() / impactBuf.rate() => now;

		", intensity ) );
	}
}</code></pre>


<p>In this tutorial, I will translate this script into one that is compiled and run once when
   the scene is opened. The new version of the script will trigger the audio file as a result
   of communication with Unity using ChucK global variables.</p>

<p>The first thing to do is move the script from <span class="mono2">OnCollisionEnter()</span>
   to <span class="mono2">Start()</span>.</p>

<pre class="line-numbers"><code class="language-csharp">void Start()
{
	rb = GetComponent&lt;Rigidbody&gt;();
	count = 0;
	SetCountText();
	winText.text = "";

	GetComponent&lt;ChuckSubInstance&gt;().RunCode( string.Format( @"
		SndBuf impactBuf => dac;
		me.dir() + ""impact.wav"" => impactBuf.read;

		// start at the beginning of the clip
		0 => impactBuf.pos;
		
		// set rate: least intense is fast, most intense is slow; range 0.4 to 1.6
		1.5 - {0} + Math.random2f( -0.1, 0.1 ) => impactBuf.rate;
			
		chout <= ""Rate is "" <= impactBuf.rate() <= IO.newline();

		// set gain: least intense is quiet, most intense is loud; range 0.05 to 1
		0.05 + 0.95 * {0} => impactBuf.gain;

		// pass time so that the file plays
		impactBuf.length() / impactBuf.rate() => now;

	", intensity ) );
}</code></pre>

<p>Next, remove the call to <span class="mono2">string.Format</span> and replace all
   of the format locations in the string with a new variable, <span class="mono2">intensity</span>.
   Wrap the entire script into a function called <span class="mono2">playImpact(&nbsp;float&nbsp;intensity&nbsp;)</span>.</p>
<pre class="line-numbers" data-line="2,10-16"><code class="language-csharp">GetComponent&lt;ChuckSubInstance&gt;().RunCode( @"
	<span class="bold">fun void playImpact( float intensity )</span>
	{
		SndBuf impactBuf => dac;
		me.dir() + ""impact.wav"" => impactBuf.read;

		// start at the beginning of the clip
		0 => impactBuf.pos;
				
		// set rate: least intense is fast, most intense is slow; range 0.4 to 1.6
		<span class="bold">1.5 - intensity + Math.random2f( -0.1, 0.1 ) => impactBuf.rate;</span>
			
		chout <= ""Rate is "" <= impactBuf.rate() <= IO.newline();

		// set gain: least intense is quiet, most intense is loud; range 0.05 to 1
		<span class="bold">0.05 + 0.95 * intensity => impactBuf.gain;</span>

		// pass time so that the file plays
		impactBuf.length() / impactBuf.rate() => now;
	}
" );
</code></pre>

<p>Now, let's add the global variables we will use to signal when this function should be called.
   We will set the value of an <span class="mono2">global float</span> from Unity, and then we
   will signal an <span class="mono2">global Event</span> from Unity to tell the ChucK script
   that it should play an impact using the value stored in the global float.</p>
<p>These variables are specified just like regular variables, but with the <span class="mono2">global</span>
   keyword. Note that only global variables can be <span class="mono2">global</span>, and currently the
   only variable types supported are int, float, string, Event, UGen, int array, and float array.</p>
<pre class="line-numbers" data-line="22-23"><code class="language-csharp">GetComponent&lt;ChuckSubInstance&gt;().RunCode( @"
	fun void playImpact( float intensity )
	{
		SndBuf impactBuf => dac;
		me.dir() + ""impact.wav"" => impactBuf.read;

		// start at the beginning of the clip
		0 => impactBuf.pos;
		
		// set rate: least intense is fast, most intense is slow; range 0.4 to 1.6
		1.5 - intensity + Math.random2f( -0.1, 0.1 ) => impactBuf.rate;
		
		chout <= ""Rate is "" <= impactBuf.rate() <= IO.newline();

		// set gain: least intense is quiet, most intense is loud; range 0.05 to 1
		0.05 + 0.95 * intensity => impactBuf.gain;

		// pass time so that the file plays
		impactBuf.length() / impactBuf.rate() => now;
	}
	
	<span class="bold">global float impactIntensity;
	global Event impactHappened;</span>
" );</code></pre>


<p>Let's write the code that uses these variables. To wait for an Event to fire,
   we simply chuck the event to <span class="mono2">now</span>. To call the <span class="mono2">playImpact</span>
   function we just defined, but in a new shred, we <span class="mono2">spork&nbsp;~</span> the function
   call.</p>
<p>So, forever (&nbsp;<span class="mono2">while(&nbsp;true&nbsp;)</span>&nbsp;), we will wait for an 
   <span class="mono2">impactHappened</span> event, and then call <span class="mono2">playImpact</span>
   with the value stored in <span class="mono2">impactIntensity</span>.</p>
<pre class="line-numbers" data-line="25-29"><code class="language-csharp">GetComponent&lt;ChuckSubInstance&gt;().RunCode( @"
	fun void playImpact( float intensity )
	{
		SndBuf impactBuf => dac;
		me.dir() + ""impact.wav"" => impactBuf.read;

		// start at the beginning of the clip
		0 => impactBuf.pos;
		
		// set rate: least intense is fast, most intense is slow; range 0.4 to 1.6
		1.5 - intensity + Math.random2f( -0.1, 0.1 ) => impactBuf.rate;
		
		chout <= ""Rate is "" <= impactBuf.rate() <= IO.newline();

		// set gain: least intense is quiet, most intense is loud; range 0.05 to 1
		0.05 + 0.95 * intensity => impactBuf.gain;

		// pass time so that the file plays
		impactBuf.length() / impactBuf.rate() => now;
	}
	
	global float impactIntensity;
	global Event impactHappened;

	<span class="bold">while( true )
	{
		impactHappened => now;
		spork ~ playImpact( impactIntensity );
	}</span>
" );</code></pre>


<p>Finally, in the <span class="mono2">OnCollisionEnter</span> function, after we compute 
   the collision's intensity, we first set the value of the float <span class="mono2">impactIntensity</span>
   and then broadcast the event <span class="mono2">impactHappened</span>. These functions take the string
   name of the ChucK plugin as the first argument and the name of the global variable as the second argument,
   since each ChucK plugin has its own namespace of global variables.</p>
<!--  TODO: prism bold -->
<pre class="line-numbers" data-line="9-11"><code class="language-csharp">void OnCollisionEnter( Collision collision )
{
	// map and clamp from [0, 16] to [0, 1]
	float intensity = Mathf.Clamp01( collision.relativeVelocity.magnitude / 16 );

	// square it to make the ramp upward more dramatic
	intensity = intensity * intensity;

	// set the intensity and fire the event
	<span class="bold">GetComponent&lt;ChuckSubInstance&gt;().SetFloat( "impactIntensity", intensity );
	GetComponent&lt;ChuckSubInstance&gt;().BroadcastEvent( "impactHappened" );</span>
}</code></pre>

<p>Congratulations! You've written a script using global variables. This practice allows you to write
   slightly more efficient code, since you won't need to send a new script to the ChucK compiler every time you want
   to generate sound.</p>
</div>

<div id="getglobal" class="lang_subtopic_body">
<h2><strong>Getting ChucK Global Variables</strong></h2>
<p>Now let's look at how to get back out the values of global variables! 
   You might want to do this if you want to do some analysis of your audio in ChucK and use the results in Unity.</p>
<p>Let's start by adding a new script onto the same game object where our ChuckSubInstance is. I'll call my script
   <span class="mono2">AudioAnalyzer</span> because it will be analyzing all the audio that comes out of the 
   <span class="mono2">dac</span> on this ChuckSubInstance.</p>

<img class="tutorialimg" src="../images/tutorial8/1.png" width=500 />

<p>In this new Unity class, I add a variable to store a float from ChucK. This is <span class="mono2">
   double mostRecentDacLoudness</span>. (Note that ChucK <span class="mono2">float</span>s correspond to Unity 
   <span class="mono2">double</span>s, and ChucK <span class="mono2">int</span>s correspond to Unity
   <span class="mono2">long</span>s.)</p>
<p>Next, I write a ChucK script. In it, I have a ChucK global variable <span class="mono2">dacLoudness</span>, and every time
   I compute the loudness of the <span class="mono2">dac</span> using an RMS Unit Analyzer ("UAna"),
   I store the result in <span class="mono2">dacLoudness</span>.</p>
<p>Then, in the Unity <span class="mono2">Update()</span> function, I call <span class="mono2">GetFloat</span> with the name
   of the float I'd like to get and a function that will be called for the ChuckSubInstance to send back the value of the float. 
   The name of the function is <span class="mono2">GetDacLoudnessCallback</span>. I pass this function using a 
   <span class="mono2">Chuck.FloatCallback</span> (here, <span class="mono2">myGetLoudnessCallback</span>), constructed
   in the Start function.</p>
<p>In <span class="mono2">GetDacLoudnessCallback</span>, I store the value of the double (remember, a ChucK float is a Unity double) into a class
   member variable to use later. Note that you cannot use many Unity-provided functions within such a callback,
   so if you want to do something other than a <span class="mono2">Debug.Log</span>, you will need to store
   the value in this way and use it somewhere else, such as in <span class="mono2">Update()</span> or
   <span class="mono2">FixedUpdate()</span>.</p>
<pre class="line-numbers" data-line="3-5,15,27-28,38,41-45"><code class="language-csharp">public class AudioAnalyzer : MonoBehaviour
{
	<span class="bold">double mostRecentDacLoudness;</span>
	ChuckSubInstance myChuck;
	<span class="bold">Chuck.FloatCallback myGetLoudnessCallback;</span>

	void Start()
	{
		myChuck = GetComponent&lt;ChuckSubInstance&gt;();
		myGetLoudnessCallback = myChuck.CreateGetFloatCallback( 
			GetDacLoudnessCallbackFunction 
		);

		myChuck.RunCode( @"
			<span class="bold">global float dacLoudness;</span>
			
			dac => FFT fft =^ RMS rms => blackhole;

			1024 => fft.size;
			Windowing.hann( fft.size() ) => fft.window;

			while( true )
			{
				// upchuck: take fft then rms
				rms.upchuck() @=> UAnaBlob data;

				// store value in global variable
				<span class="bold">data.fval(0) => dacLoudness;</span>

				// advance time
				fft.size()::samp => now;
			}	
		" );
	}

	void Update()
	{
		<span class="bold">myChuck.GetFloat( "dacLoudness", myGetLoudnessCallback );</span>
	}

	void GetDacLoudnessCallbackFunction( <span class="bold">double dacLoudness</span> )
	{
		<span class="bold">mostRecentDacLoudness = dacLoudness;</span>
		Debug.Log( "got a value for dac loudness: " + dacLoudness.ToString( "0.000" ) );
	}
}</code></pre>


<p>This script might work most of the time, but it can be cumbersome to work this way. The reason why you can't 
   access much of the Unity functionality from your callback function, and have to store the value instead,
   is because this function is being called from the audio thread, rather than the graphics thread (which
   is where functions like Update are called from).</p>
<p>You can use a helper component to encapsulate all this inter-thread communication. Here, I use a
   <span class="mono2">ChuckFloatSyncer</span> to keep the value of the global float <span class="mono2">dacLoudness</span>
   synced with the graphics thread. You can always get the most recently fetched value from the syncer with the 
   <span class="mono2">GetCurrentValue()</span> function.</p>

<pre class="line-numbers" data-line="4,30-31,37"><code class="language-csharp">public class AudioAnalyzer : MonoBehaviour
{
	ChuckSubInstance myChuck;
	<span class="bold">ChuckFloatSyncer myGetLoudnessSyncer;</span>

	void Start()
	{
		myChuck = GetComponent&lt;ChuckSubInstance&gt;();
		myChuck.RunCode( @"
			global float dacLoudness;
			
			dac => FFT fft =^ RMS rms => blackhole;

			1024 => fft.size;
			Windowing.hann( fft.size() ) => fft.window;

			while( true )
			{
				// upchuck: take fft then rms
				rms.upchuck() @=> UAnaBlob data;

				// store value in global variable
				data.fval(0) => dacLoudness;

				// advance time
				fft.size()::samp => now;
			}	
		" );

		<span class="bold">myGetLoudnessSyncer = gameObject.AddComponent&lt;ChuckFloatSyncer&gt;();
		myGetLoudnessSyncer.SyncFloat( myChuck, "dacLoudness" );</span>
	}

	void Update()
	{
		Debug.Log( "most recent dac loudness: " + 
			<span class="bold">myGetLoudnessSyncer.GetCurrentValue()</span>.ToString( "0.000" )
		);
	}
}</code></pre>


<p>Congratulations! You've written a script to get the value of a ChucK global variable! Now you can communicate
   the results of ChucK computation back to Unity!</p>
</div>

<div id="chugins" class="lang_subtopic_body">
<h2><strong>Chugins</strong></h2>
<p>It's possible to write additions to ChucK in C++ and compile these additions
   as dynamically linked libraries (known as <a target="_blank" href="http://chuck.stanford.edu/extend/#chugins">ChuGins</a>).
   If you're interested in writing your own ChuGin, check out the 
   <a target="_blank" href="https://github.com/ccrma/chugins">GitHub</a>
   repository for more information.</p>
<p>In Unity, any ChuGin that is added to the <span class="mono2">StreamingAssets/Chugins</span>
   folder is automatically usable in any ChucK script.
   (StreamingAssets is the same folder that is used to store your <a href="#audiofiles">audio files</a>.)</p>
<p>ChuGins often take the form of new UGens (unit generators), the core objects that
   process all audio in ChucK.</p>
<p>For example, if I add the <span class="mono2">Bitcrusher.chug</span> ChuGin to
   my Chugins folder...</p>
<img class="tutorialimg" src="../images/tutorial7/1.png" width=350 />

<p>... then, I can write ChucK scripts using the Bitcrusher UGen!</p>
<p>Here, I've modified the <a href="#audiofiles">Audio File</a> impact script
   to process my audio file through a Bitcrusher. To do this, I just added
   the Bitcrusher to the signal flow, set its settings, and allowed some extra
   time at the end of the audio file to wait for the Bitcrusher's tail of audio
   to finish playing.</p>
<pre class="line-numbers" data-line="4,18-21,24"><code class="language-csharp">GetComponent&lt;ChuckSubInstance&gt;().RunCode( @"
	fun void playImpact( float intensity )
	{
		SndBuf impactBuf => <span class="bold">Bitcrusher bc</span> => dac;
		me.dir() + ""impact.wav"" => impactBuf.read;

		// start at the beginning of the clip
		0 => impactBuf.pos;
		
		// set rate: least intense is fast, most intense is slow; range 0.4 to 1.6
		1.5 - intensity + Math.random2f( -0.1, 0.1 ) => impactBuf.rate;
		
		chout <= ""Rate is "" <= impactBuf.rate() <= IO.newline();

		// set gain: least intense is quiet, most intense is loud; range 0.05 to 1
		0.05 + 0.95 * intensity => impactBuf.gain;

		// bitcrusher settings
		<span class="bold">0.5 => bc.gain;
		7 => bc.bits;
		3 => bc.downsampleFactor;</span>

		// pass time so that the file plays
		impactBuf.length() / impactBuf.rate() + <span class="bold">5::second</span> => now;
	}
	
	global float impactIntensity;
	global Event impactHappened;

	while( true )
	{
		impactHappened => now;
		spork ~ playImpact( impactIntensity );
	}
" );</code></pre>

<!-- NOTE: disabled while Faust doesn't work on windows and there's a syntax error in the Faust script.
<p>ChuGins have been used to extend ChucK in pretty fantastic ways. For example,
   you can write <a target="_blank" href="http://faust.grame.fr/">Faust</a> signal processing code 
   in ChucK using the Faust ChuGin!</p>
<p>Just add the Faust.chug Chugin to your StreamingAssets folder...</p>
<img class="tutorialimg" src="../images/tutorial7/3.png" width=300 />

<p>... and then, you can write Faust code inside your ChucK code inside your Unity code!</p>
<img class="tutorialimg" src="../images/tutorial7/4.png" width=500 />
<p>Wow! That's Fausttastic!</p>
-->
<p>Thanks for following these tutorials. Good luck ChucKing in Unity!</p>
</div>




<!-- end subtopics -->

</div>
</div>
</td></tr>

<!-- navigation bar -->

<tr><td>
<center>
<div class="chuck_nav">

	<table border="0"><tbody><tr><td>
	<center>
	<div class="chuck_nav_bar">	
  (up): <a href="..">chunity</a> <!-- | (next): <a href="">next link</a> &gt;  -->
	</div>
	</center>  
	</td></tr></tbody></table>

</div>
</center>
</td></tr>

<!-- chuck-footer -->

<tr><td>
<div id="chuck_footer">
<center>
<hr width="15%">
<a href="http://chuck.stanford.edu/">chuck</a> |
<a href="http://soundlab.cs.princeton.edu/">soundlab</a> |
<a href="http://ccrma.stanford.edu/">ccrma</a>

</center>
</div>
</td></tr>
</tbody></table>

</center>

<script src="../js/prism.js"></script>
</body></html>
